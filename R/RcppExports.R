# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Allocate energy flows to batteries.
#'
#' Given a number of factors, the function returns the
#' demand and updated state of charge of the batteries.
#' @param flow Energy flow to be exchanged in the following time step .
#' Positive for charge, negative for discharge.
#' @param soc Current state of charge.
#' @param vol Objective state of charge to be achieved.
#' @param share Double, indicating the priority to share the energy flow
#' @param level Integer, expressing the priority to be resolved, starting with
#' the highest.
#' @param active boolean, expressing whether the battery should be considered
#' @param eff Efiiciency of the energy flow.
#' @param cap Maximum energy that can be exchanged witht the battery
#'
#' @return An object containing the state of charge of each battery, its final
#' energy flow, and a double containing the energy that was not shared
NULL

allocate <- function(flow, soc, vol, share = as.numeric( c(1)), level = as.numeric( c(1)), active = as.logical( c(1)), eff = as.numeric( c(1)), cap = as.numeric( c(0))) {
    .Call('_eflows_allocate', PACKAGE = 'eflows', flow, soc, vol, share, level, active, eff, cap)
}

subset_range <- function(vec, start, end) {
    .Call('_eflows_subset_range', PACKAGE = 'eflows', vec, start, end)
}

depreciate <- function(x, depreciation) {
    .Call('_eflows_depreciate', PACKAGE = 'eflows', x, depreciation)
}

seq_depreciated <- function(length, depreciation) {
    .Call('_eflows_seq_depreciated', PACKAGE = 'eflows', length, depreciation)
}

backshift <- function(matrix, price, horizon, depreciation, cap, size) {
    .Call('_eflows_backshift', PACKAGE = 'eflows', matrix, price, horizon, depreciation, cap, size)
}

formatFlexSteps <- function(matrix, flex_step, max_step = -1L) {
    .Call('_eflows_formatFlexSteps', PACKAGE = 'eflows', matrix, flex_step, max_step)
}

divideInChunks <- function(x, precision) {
    .Call('_eflows_divideInChunks', PACKAGE = 'eflows', x, precision)
}

whichMin <- function(x) {
    .Call('_eflows_whichMin', PACKAGE = 'eflows', x)
}

sliceCurrent <- function(vec, start, end) {
    .Call('_eflows_sliceCurrent', PACKAGE = 'eflows', vec, start, end)
}

envCurrent <- function(input, out, start, span) {
    .Call('_eflows_envCurrent', PACKAGE = 'eflows', input, out, start, span)
}

listToCube <- function(mtx_list) {
    .Call('_eflows_listToCube', PACKAGE = 'eflows', mtx_list)
}

cubeToList <- function(xcube) {
    .Call('_eflows_cubeToList', PACKAGE = 'eflows', xcube)
}

foreShiftCpp <- function(mtx_list, env_fit, call, env_current, def_demand, cap = 0, cap_spread = TRUE) {
    .Call('_eflows_foreShiftCpp', PACKAGE = 'eflows', mtx_list, env_fit, call, env_current, def_demand, cap, cap_spread)
}

model_c <- function(df, df_battery, initial_soc, to_battery_eff, from_battery_eff, to_ev_eff, from_ev_eff, max_battery_rate, ev_priority_charge = 0.5, ev_priority_discharge = 0.5, grid_capacity = 10, use_grid_cap = TRUE, use_v2g = TRUE, charge_thold = 0.7, v2g_thold = 0.9, pref_charge_stationary = 0.5, pref_discharge_stationary = 0.5, pref_charge_ev = 0.5, pref_discharge_ev = 0.5) {
    .Call('_eflows_model_c', PACKAGE = 'eflows', df, df_battery, initial_soc, to_battery_eff, from_battery_eff, to_ev_eff, from_ev_eff, max_battery_rate, ev_priority_charge, ev_priority_discharge, grid_capacity, use_grid_cap, use_v2g, charge_thold, v2g_thold, pref_charge_stationary, pref_discharge_stationary, pref_charge_ev, pref_discharge_ev)
}

divide <- function(x, precision = 0.01) {
    .Call('_eflows_divide', PACKAGE = 'eflows', x, precision)
}

present <- function(vec, start, end) {
    .Call('_eflows_present', PACKAGE = 'eflows', vec, start, end)
}

xts_index <- function(xts_mtx) {
    .Call('_eflows_xts_index', PACKAGE = 'eflows', xts_mtx)
}

signif_ccp <- function(value, digits) {
    .Call('_eflows_signif_ccp', PACKAGE = 'eflows', value, digits)
}

tell_min <- function(x) {
    .Call('_eflows_tell_min', PACKAGE = 'eflows', x)
}

signif_step <- function(matrix, denom) {
    .Call('_eflows_signif_step', PACKAGE = 'eflows', matrix, denom)
}

