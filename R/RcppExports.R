# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Allocate energy flows to batteries.
#'
#' Given a number of factors, the function returns the
#' demand and updated state of charge of the batteries.
#' @param flow Energy flow to be exchanged in the following time step .
#' Positive for charge, negative for discharge.
#' @param soc Current state of charge.
#' @param vol Objective state of charge to be achieved.
#' @param share Double, indicating the priority to share the energy flow
#' @param level Integer, expressing the priority to be resolved, starting with
#' the highest.
#' @param active boolean, expressing whether the battery should be considered
#' @param eff Efiiciency of the energy flow.
#' @param cap Maximum energy that can be exchanged witht the battery
#'
#' @return An object containing the state of charge of each battery, its final
#' energy flow, and a double containing the energy that was not shared
#' @export
allocate <- function(flow, soc, vol, share = as.numeric( c(1)), level = as.numeric( c(1)), active = as.logical( c(1)), eff = as.numeric( c(1)), cap = as.numeric( c(0))) {
    .Call('_eflows_allocate', PACKAGE = 'eflows', flow, soc, vol, share, level, active, eff, cap)
}

subset_range <- function(vec, start, end) {
    .Call('_eflows_subset_range', PACKAGE = 'eflows', vec, start, end)
}

depreciate <- function(x, depreciation) {
    .Call('_eflows_depreciate', PACKAGE = 'eflows', x, depreciation)
}

seq_depreciated <- function(length, depreciation) {
    .Call('_eflows_seq_depreciated', PACKAGE = 'eflows', length, depreciation)
}

#' Shift energy consumption towards the past.
#'
#'
#' @return A matrix, or an xts object if the index provided are a POSIXct object.
#' @export
backshift <- function(matrix, price, horizon, depreciation, cap, size) {
    .Call('_eflows_backshift', PACKAGE = 'eflows', matrix, price, horizon, depreciation, cap, size)
}

#' Shift energy consumption towards the future.
#'
#' In function of a fitting curve and the flexibility time, the consumption of
#' energy is delayed.
#' @param matrix Numeric matrix, each row an observation in time (it can be a time series)
#' and each column representing the flexibility of demand, increasing towards the right.
#' @param flex_step Integer vector of same length of the column of `matrix`, indicating
#' the number of timesteps the demand can be delayed. Normally, the first integer is `0`,
#' indicating the `solid` demand.
#' @param cap If higher than 0, indicates the maximum capacity of flexible demand
#' that can be allocated in a timestep.
#' @param cap_spread Boolean. if true, the cap is never exceeded, and instead the
#' consumption is displaced towards the future, and resolved as soon as possible.
#' @param foresee Boolean. If false, it indicates a complete lack of knowledge of the
#' future flexible demand in the timeline.
#' @param solar If present, the fitting curve is calculated substracting solar
#' from the demand.
#'
#' @return A matrix, or an xts object if the index provided are a POSIXct object.
#' @export
foreshift <- function(matrix, flex_step, cap = 0, cap_spread = TRUE, foresee = TRUE, solar = as.numeric( c(0))) {
    .Call('_eflows_foreshift', PACKAGE = 'eflows', matrix, flex_step, cap, cap_spread, foresee, solar)
}

model_c <- function(df, df_battery, initial_soc, to_battery_eff, from_battery_eff, to_ev_eff, from_ev_eff, max_battery_rate, ev_priority_charge = 0.5, ev_priority_discharge = 0.5, grid_capacity = 10, use_grid_cap = TRUE, use_v2g = TRUE, charge_thold = 0.7, v2g_thold = 0.9, pref_charge_stationary = 0.5, pref_discharge_stationary = 0.5, pref_charge_ev = 0.5, pref_discharge_ev = 0.5) {
    .Call('_eflows_model_c', PACKAGE = 'eflows', df, df_battery, initial_soc, to_battery_eff, from_battery_eff, to_ev_eff, from_ev_eff, max_battery_rate, ev_priority_charge, ev_priority_discharge, grid_capacity, use_grid_cap, use_v2g, charge_thold, v2g_thold, pref_charge_stationary, pref_discharge_stationary, pref_charge_ev, pref_discharge_ev)
}

divide <- function(x, precision = 0.01) {
    .Call('_eflows_divide', PACKAGE = 'eflows', x, precision)
}

present <- function(vec, start, end) {
    .Call('_eflows_present', PACKAGE = 'eflows', vec, start, end)
}

xts_index <- function(xts_mtx) {
    .Call('_eflows_xts_index', PACKAGE = 'eflows', xts_mtx)
}

signif_ccp <- function(value, digits) {
    .Call('_eflows_signif_ccp', PACKAGE = 'eflows', value, digits)
}

tell_min <- function(x) {
    .Call('_eflows_tell_min', PACKAGE = 'eflows', x)
}

signif_step <- function(matrix, denom) {
    .Call('_eflows_signif_step', PACKAGE = 'eflows', matrix, denom)
}

